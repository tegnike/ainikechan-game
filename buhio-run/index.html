<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>„Éñ„ÉíÂ§´„É©„É≥„Éä„Éº</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { 
            overflow: hidden; 
            background: #1a1a2e;
            font-family: sans-serif;
        }
        #game-container { 
            width: 100vw; 
            height: 100vh; 
        }
        #ui {
            position: fixed;
            top: 20px;
            left: 20px;
            color: #fff;
            font-size: 24px;
            z-index: 100;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
        }
        #score { color: #ffd700; }
        #instructions {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            color: #aaa;
            font-size: 16px;
            z-index: 100;
        }
        #game-over {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #ff4444;
            font-size: 48px;
            font-weight: bold;
            z-index: 100;
            display: none;
            text-shadow: 2px 2px 8px rgba(0,0,0,0.8);
        }
        #start-screen {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            z-index: 100;
        }
        #start-screen h1 {
            color: #ffd700;
            font-size: 64px;
            margin-bottom: 20px;
            text-shadow: 3px 3px 6px rgba(0,0,0,0.8);
        }
        #start-screen p {
            color: #fff;
            font-size: 24px;
            margin-bottom: 30px;
        }
        #start-btn {
            background: #5A4C97;
            color: #fff;
            border: none;
            padding: 15px 40px;
            font-size: 24px;
            cursor: pointer;
            border-radius: 10px;
            transition: transform 0.2s;
        }
        #start-btn:hover {
            transform: scale(1.1);
        }
    </style>
</head>
<body>
    <div id="game-container"></div>
    
    <div id="ui">
        <div id="score">„Çπ„Ç≥„Ç¢: 0</div>
    </div>
    
    <div id="instructions">
        ‚Üê ‚Üí „Åæ„Åü„ÅØ A D „ÅßÁßªÂãï | „Çπ„Éö„Éº„Çπ„Åß„Ç∏„É£„É≥„Éó
    </div>
    
    <div id="game-over">„Ç≤„Éº„É†„Ç™„Éº„Éê„Éº!</div>
    
    <div id="start-screen">
        <h1>üèÉ „Éñ„ÉíÂ§´„É©„É≥„Éä„Éº üèÉ</h1>
        <p>ÈöúÂÆ≥Áâ©„ÇíÈÅø„Åë„Å¶Ëµ∞„ÇäÁ∂ö„Åë„Çà„ÅÜÔºÅ</p>
        <button id="start-btn">„Çπ„Çø„Éº„ÉàÔºÅ</button>
    </div>

    <script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
            "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
        }
    }
    </script>
    
    <script type="module">
        import * as THREE from 'three';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';

        // Game state
        let gameState = {
            isPlaying: false,
            score: 0,
            speed: 0.3,
            buhioX: 0,
            buhioY: 0,
            velocityY: 0,
            isJumping: false,
            obstacles: []
        };

        // Scene setup
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x87CEEB);
        scene.fog = new THREE.Fog(0x87CEEB, 20, 100);

        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 5, 15);
        camera.lookAt(0, 2, 0);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        document.getElementById('game-container').appendChild(renderer.domElement);

        // Lighting
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);

        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
        directionalLight.position.set(10, 20, 10);
        directionalLight.castShadow = true;
        scene.add(directionalLight);

        // Ground
        const groundGeometry = new THREE.PlaneGeometry(100, 1000);
        const groundMaterial = new THREE.MeshStandardMaterial({ 
            color: 0x7CFC00,
            roughness: 0.8
        });
        const ground = new THREE.Mesh(groundGeometry, groundMaterial);
        ground.rotation.x = -Math.PI / 2;
        ground.position.z = -450;
        ground.receiveShadow = true;
        scene.add(ground);

        // Road lanes (3 lanes)
        const laneWidth = 3;
        const lanes = [-laneWidth, 0, laneWidth];

        // Road
        const roadGeometry = new THREE.PlaneGeometry(12, 1000);
        const roadMaterial = new THREE.MeshStandardMaterial({ color: 0x333333 });
        const road = new THREE.Mesh(roadGeometry, roadMaterial);
        road.rotation.x = -Math.PI / 2;
        road.position.y = 0.01;
        road.position.z = -450;
        scene.add(road);

        // Lane markers
        for (let i = -1.5; i <= 1.5; i += 1.5) {
            if (i !== 0) {
                for (let z = 0; z > -1000; z -= 5) {
                    const marker = new THREE.Mesh(
                        new THREE.PlaneGeometry(0.2, 2),
                        new THREE.MeshStandardMaterial({ color: 0xffffff })
                    );
                    marker.rotation.x = -Math.PI / 2;
                    marker.position.set(i, 0.02, z);
                    scene.add(marker);
                }
            }
        }

        // Buhio (placeholder)
        let buhio;
        const buhioGeometry = new THREE.BoxGeometry(1.5, 2.5, 1);
        const buhioMaterial = new THREE.MeshStandardMaterial({ color: 0xFFB6C1 });
        buhio = new THREE.Mesh(buhioGeometry, buhioMaterial);
        buhio.position.set(0, 1.25, 0);
        buhio.castShadow = true;
        scene.add(buhio);

        // Obstacle creation
        function createObstacle() {
            const lane = lanes[Math.floor(Math.random() * 3)];
            const types = ['box', 'cone', 'barrel'];
            const type = types[Math.floor(Math.random() * types.length)];
            
            let obstacle;
            
            if (type === 'box') {
                obstacle = new THREE.Mesh(
                    new THREE.BoxGeometry(1.5, 1.5, 1.5),
                    new THREE.MeshStandardMaterial({ color: 0xff4444 })
                );
                obstacle.position.y = 0.75;
            } else if (type === 'cone') {
                obstacle = new THREE.Mesh(
                    new THREE.ConeGeometry(0.7, 2, 8),
                    new THREE.MeshStandardMaterial({ color: 0xff8800 })
                );
                obstacle.position.y = 1;
            } else {
                obstacle = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.6, 0.6, 1.5, 16),
                    new THREE.MeshStandardMaterial({ color: 0x4444ff })
                );
                obstacle.position.y = 0.75;
            }
            
            obstacle.position.x = lane;
            obstacle.position.z = -80;
            obstacle.castShadow = true;
            
            scene.add(obstacle);
            gameState.obstacles.push(obstacle);
        }

        // Input handling
        const keys = {};
        window.addEventListener('keydown', (e) => {
            keys[e.code] = true;
            if (e.code === 'Space' && !gameState.isJumping && gameState.isPlaying) {
                gameState.velocityY = 0.4;
                gameState.isJumping = true;
            }
        });
        window.addEventListener('keyup', (e) => keys[e.code] = false);

        // Start button
        document.getElementById('start-btn').addEventListener('click', startGame);

        function startGame() {
            document.getElementById('start-screen').style.display = 'none';
            gameState.isPlaying = true;
            gameState.score = 0;
            gameState.speed = 0.3;
            gameState.buhioX = 0;
            gameState.buhioY = 0;
            gameState.velocityY = 0;
            
            gameState.obstacles.forEach(o => scene.remove(o));
            gameState.obstacles = [];
            
            document.getElementById('game-over').style.display = 'none';
        }

        function gameOver() {
            gameState.isPlaying = false;
            document.getElementById('game-over').style.display = 'block';
            document.getElementById('start-screen').style.display = 'block';
            document.getElementById('start-screen').querySelector('p').textContent = 
                'ÊúÄÁµÇ„Çπ„Ç≥„Ç¢: ' + gameState.score;
        }

        // Collision detection
        function checkCollision() {
            const buhioBox = new THREE.Box3().setFromObject(buhio);
            
            for (const obstacle of gameState.obstacles) {
                const obstacleBox = new THREE.Box3().setFromObject(obstacle);
                if (buhioBox.intersectsBox(obstacleBox)) {
                    return true;
                }
            }
            return false;
        }

        // Animation loop
        let lastObstacleTime = 0;
        
        function animate(time) {
            requestAnimationFrame(animate);
            
            if (gameState.isPlaying) {
                // Horizontal movement
                if (keys['ArrowLeft'] || keys['KeyA']) {
                    gameState.buhioX = Math.max(gameState.buhioX - 0.15, -laneWidth);
                }
                if (keys['ArrowRight'] || keys['KeyD']) {
                    gameState.buhioX = Math.min(gameState.buhioX + 0.15, laneWidth);
                }
                
                // Jump physics
                if (gameState.isJumping) {
                    gameState.velocityY -= 0.02;
                    gameState.buhioY += gameState.velocityY;
                    
                    if (gameState.buhioY <= 0) {
                        gameState.buhioY = 0;
                        gameState.isJumping = false;
                        gameState.velocityY = 0;
                    }
                }
                
                // Update Buhio position
                buhio.position.x = gameState.buhioX;
                buhio.position.y = gameState.buhioY + 1;
                
                // Running animation
                buhio.rotation.z = Math.sin(time * 0.01) * 0.1;
                
                // Move obstacles
                for (let i = gameState.obstacles.length - 1; i >= 0; i--) {
                    const obstacle = gameState.obstacles[i];
                    obstacle.position.z += gameState.speed;
                    
                    if (obstacle.position.z > 5) {
                        scene.remove(obstacle);
                        gameState.obstacles.splice(i, 1);
                        gameState.score += 10;
                    }
                }
                
                // Spawn new obstacles
                if (time - lastObstacleTime > 1500) {
                    createObstacle();
                    lastObstacleTime = time;
                }
                
                // Increase difficulty
                gameState.speed = Math.min(0.3 + gameState.score * 0.0001, 0.8);
                
                // Update score display
                document.getElementById('score').textContent = '„Çπ„Ç≥„Ç¢: ' + gameState.score;
                
                // Check collision
                if (checkCollision()) {
                    gameOver();
                }
            }
            
            renderer.render(scene, camera);
        }

        animate(0);

        // Handle resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
